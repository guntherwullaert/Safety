\documentclass{article}
%\usepackage{bm}
%\usepackage{breqn}
\usepackage{amsmath}

\title{Definition of Safety}
\author{GÃ¼nther Wullaert}
\date{May 2022}

\newcommand{\pool}[1]{\boldsymbol{#1}}
\newcommand{\tuple}[1]{\dot{#1}}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\dep}[2]{\{(#1), (#2)\}}
\newcommand{\provide}[2]{\{(\{#1\}, \{#2\})\}}
\newcommand{\provideM}[4]{\{(\{#1\}, \{#2\}), (\{#3\},\{#4\})\}}
\newcommand{\provideMM}[6]{\{(\{#1\}, \{#2\}), (\{#3\},\{#4\}), (\{#5\},\{#6\})\}}
\newcommand{\provideMMM}[8]{\{(\{#1\}, \{#2\}), (\{#3\},\{#4\}), (\{#5\},\{#6\}), (\{#7\},\{#8\})\}}

\newcommand\Vars[1]{\mathit{vars}(#1)}
\newcommand\DP[1]{\mathit{dep}(#1)}
\newcommand\CheckOp[1]{C_{#1}}
\newcommand\CheckAp[2]{\CheckOp{#1}({#2})}

\begin{document}
	\maketitle
	
	\section{Language}
	\subsection{Term and Pools}
	
	We inductively define terms, tuples of terms, and pools as
	\begin{itemize}
		\item all numerals, symbolic constants, and variables are terms,
		\item $f(\pool{t})$ is a term, if $f$ is a symbolic constant and $\pool{t}$ is a pool,
		\item $t_1 \star t_2$ is a term, if $\star$ is among the symbols +, -, $\times$, / or .. and $t_1$, $t_2$ are terms,
		\item $\langle \pool{t} \rangle$ is a term, if $\pool{t}$ is a pool, which can have a possibly empty set of terms,
		\item $t_1,...,t_n$ is a tuple of terms, if $n \ge 0$ and $t_i$ is a term,
  		\item $\tuple{t_1};...;\tuple{t_n}$ is a pool, if $n \ge 1$ and each $\tuple{t_i}$ is a tuple of terms.
	\end{itemize}

	\subsection{Constants}

	We inductively define a term to be $\mathit{constant}$ if
	\begin{itemize}
		\item it is a numeral,
		\item it has form $t \star u$ where t and u are $\mathit{constant}$ and $\star$ is among the symbols +, -, $\times$ or /.
	\end{itemize}

	\subsection{Atoms and Literals}
	
	An atom has form $p(\pool{t})$ where $p$ is a predicate symbol and $\pool{t}$ is a pool. 
	\\
	A comparison literal has form $t_1 \prec t_2$, where $t_1,t_2$ are terms and $\prec$ is among the symbols $\leq,\ge,<,>$ or $\neq$.
	\\
	A conditional literal has form $l : \tuple{c}$, where $l$ is a literal and $c$ is a tuple of literals.
	\\
	A literal is either an
	\begin{itemize}
		\item atom,
		\item comparison literal or
		\item conditional literal,
	\end{itemize}
	which can be preceded by not.

	\subsection{Aggregates}
	An aggregate has the form
	\begin{align}
		&\alpha\{\tuple{t_1} : \tuple{L_1}; \dots; \tuple{t_n} : \tuple{L_n}\} \prec s \label{aggregate1}
	\end{align}
	$(n \leq 0)$, where
	\begin{itemize}
		\item $\alpha$ is an aggregate name,
		\item each $\tuple{t_i}$ is a tuple of terms,
		\item each $\tuple{L_i}$ is a tuple of comparison literals and atoms,
		\item each $\prec$ is among the symbols $\leq,\ge,<,>,=$ or $\neq$,
		\item each $s$ is a term.
	\end{itemize}

	\subsection{Rules}

	A rule $r$ has the form
	\begin{equation}
		H_1 \lor ... \lor H_m  \leftarrow B_1 \land ... \land B_n \label{rule}
	\end{equation}
	($m, n \ge 0$), where each $H_i$ is a literal and each $B_j$ is a literal or an aggregate.

	\subsection{Choice Rules}
	A choice rule of form
	\begin{align}
		&\alpha\{e_1, ..., e_m\}\beta :- B_1 \land ... \land B_n \label{choice}
	\end{align}
	($m, n \ge 0$), where each $e_i$ is an atom and each $B_j$ is a literal or an aggregate. $\alpha$ and $\beta$ can be omitted and do not affect safety.

	\section{Safety}
	The $\mathit{vars(e)}$ function returns all variables for an expression $e$.
	\\ For Example:
	\begin{equation*}
		vars(a(X) = b(Y)) = \set{X,Y}
	\end{equation*}
	The $\mathit{eval(c)}$ function takes a constant term and returns the arithmetic evaluation of that term. If this function for a $\mathit{constant}$ returns a set $s$, where $0 \notin s $ then this result is called $\mathit{nonzero}$.
	\begin{align*}
		\mathit{eval}(c) &= \set{c} && \\
		\mathit{eval}(a + b) &= \set{ x + y &|\;& x \in eval(a), y \in eval(b) } \\
		\mathit{eval}(a - b) &= \set{ x - y &|\;& x \in eval(a), y \in eval(b) } \\
		\mathit{eval}(a * b) &= \set{ x * y &|\;& x \in eval(a), y \in eval(b) } \\
		\mathit{eval}(a / b) &= \set{ x / y &|\;& x \in eval(a), y \in eval(b), y \neq 0 }
	\end{align*}

	\subsection{Terms}
	\subsubsection{Constants}
	For any numeral $n$ and symbolic constant $f$
	\begin{equation*}
		pt(n) = pt(f) = dt(n) = dt(f) = \emptyset
	\end{equation*}

	\subsubsection{Variables}
	For any variable $X$
	\begin{align*}
		pt(X) &= \set{X} \\
		dt(X) &= \emptyset
	\end{align*}

	\subsubsection{Tuples}
	For any tuple of terms $t_1,...,t_n$
	\begin{align*}
		pt(t_1,...,t_n) &= pt(t_1) \cup \dots \cup pt(t_n) \\
		dt(t_1,...,t_n) &= dt(t_1) \cup \dots \cup dt(t_n)
	\end{align*}

	\subsubsection{Pools}
	For any pool of terms $\tuple{t_1};...;\tuple{t_n}$
	\begin{align*}
		pt(\tuple{t_1};...;\tuple{t_n}) &= pt(\tuple{t_1}) \cap \dots \cap pt(\tuple{t_n}) \\
		dt(\tuple{t_1};...;\tuple{t_n}) &= dt(\tuple{t_1}) \cup \dots \cup dt(\tuple{t_n})
	\end{align*}

	%% Function 
	\subsubsection{Functions}
	For a term of form $f(\pool{t})$, where $f$ is a function and $\pool{t}$ a pool
	\begin{align*}
		pt(f(\pool{t})) &= pt(\pool{t}) \\
		dt(f(\pool{t})) &= dt(\pool{t})
	\end{align*}
	%%
	\subsubsection{Arithmetics}
	For a term of form $a \star b$, where $a,b$ are terms and one of them is a $\mathit{constant}$ and $\star$ is among the symbols +, - or $a$ and $b$ are both $\mathit{constant}$ and $\star$ is among the symbols +, -, / or ..
	\begin{align*}
		pt(a \star b) &= pt(a) \cup pt(b) \\
		dt(a \star b) &= dt(a) \cup dt(b)
	\end{align*}
	Otherwise for a term of form $a \star b$, where $a,b$ are terms and none of them are $\mathit{constant}$ and $\star$ is among the symbols +, -, $\times$, / or ..
	\begin{align*}
		pt(a \star b) &= \emptyset \\
		pt(a \star b) &= vars(a \star b)
	\end{align*}
	For a term of form $a \times b$, where $a,b$ are terms and one of them is a $\mathit{constant}$ and $0 \in \mathit{eval}(a)$ or $0 \in \mathit{eval}(b)$
	\begin{align*}
		pt(a \times b) &= \emptyset \\
		dt(a \times b) &= \emptyset
	\end{align*}
	Otherwise if $0 \notin eval(a) \cup eval(b)$
	\begin{align*}
		pt(a \times b) &= pt(a) \cup pt(b) \\
		dt(a \times b) &= dt(a) \cup dt(b)
	\end{align*}
	%%
	For a term of form $-t$, where $t$ is a term
	\begin{align*}
		pt(-t) &= pt(t) \\
		dt(-t) &= dt(t)
	\end{align*}

	\subsection{Atoms and Literals}
	\subsubsection{Atoms and Literals}
	For an literal of form $not \; a$, where $a$ is an atom
	\begin{equation*}
		dep(not \; a) = \set{(\emptyset, vars(a))}
	\end{equation*}
	For an atom of form $p(\pool{t})$, where $\pool{t}$ is a pool
	\begin{equation*}
		dep(p(\pool{t})) = \dep{pt(\pool{t}), \emptyset}{\emptyset, dt(\pool{t})}
	\end{equation*}

	\subsubsection{Comparison Literals}
	For an comparison literal of form $a \prec b$, where $a$ and $b$ are terms and $\prec$ is among the symbols $\leq,\ge,<,>,\neq$
	\begin{equation*}
		dep(a \prec b) = \set{(\emptyset, vars(a \prec b))}
	\end{equation*}
	For an comparison literal of form $a = b$, where $a$ and $b$ are terms
	\begin{equation*}
		dep(a = b) = \set{(pt(a), vars(b)), (pt(b), vars(a)), (\emptyset, dt(a) \cup dt(b))}
	\end{equation*}
	For an literal of form $not \; a \prec b$, where $a$ and $b$ are terms
	\begin{align*}
		dep(not \; a = b) &= dep(a \neq b) \\
		dep(not \; a \neq b) &= dep(a = b) \\
		dep(not \; a \leq b) &= dep(a > b) \\
		dep(not \; a > b) &= dep(a \leq b) \\
		dep(not \; a \ge b) &= dep(a < b) \\
		dep(not \; a < b) &= dep(a \ge b)
	\end{align*}

	\subsubsection{Conditional Literals}
	For a conditional literal of form $\tuple{t} : \tuple{c}$, where $t$ is a tuple of terms and $c$ is a tuple of comparison literals and atoms, where $G$ is the set of variables occuring globally in it.
	\begin{align*}
		dep(\tuple{t} : \tuple{c}) &= \set{(\emptyset, G \cup vars(s))}
	\end{align*}
	For an conditional literal of form $\tuple{t} : \tuple{c}$, where $t$ is a tuple of terms and $c$ is a tuple of comparison literals and atoms in a local context
	\begin{align*}
		dep_l(\tuple{t} : \tuple{c}) = \set{(\emptyset, vars(\tuple{t}))} \cup \bigcup_{e \in \tuple{c}} dep(e)
	\end{align*}

	\subsection{Aggregates}
	For a aggragate~$a$ occuring in a rule, where $G$ is the set of variables occuring globally in it.
	We define $elem(a)$ to return a set of elements in $a$ as
	\begin{align*}
		elem(a) = \set{\tuple{t_1} : \tuple{L_1}, \dots , \tuple{t_n} : \tuple{L_n}}
	\end{align*}
	For an aggregate element of form $\tuple{t_1} : \tuple{L_1}$, where $t_1$ is a tuple of terms and $\tuple{L_1}$ is a tuple of comparison literals and atoms
	\begin{align*}
		dep(\tuple{t_1} : \tuple{L_1}) = \set{(\emptyset, vars(\tuple{t_1}))} \cup \bigcup_{l \in \tuple{L_1}} dep(l)
	\end{align*}
	For an aggregate~$a$, where $\prec$ is $=$
	\begin{align*}
		dep(a) = \set{(pt(s), G), (\emptyset, dt(s) \cup G)}
	\end{align*}
	Otherwise
	\begin{align*}
		dep(a) = \set{(\emptyset, G \cup vars(s))}
	\end{align*}

	\subsection{Rule}
	For a rule $r$ in the form of (\ref{rule}) the following holds:
	\begin{align*}
		dep(r) &= \set{(\emptyset, vars(H_1\vee ... \vee H_k))} \cup dep(B_1) \cup ... \cup dep(B_m)
	\end{align*}

	\subsection{Choice Rule}
	For a choice rule $r$ in the form of (\ref{choice}) the following holds:
	\begin{align*}
		dep(r) &= \set{(\emptyset, vars(e_1\vee ... \vee e_k))} \cup dep(B_1) \cup ... \cup dep(B_m)
	\end{align*}

	\subsection{Safety Definition}
	We define operator~$\CheckOp{r}$ for a rule~$r$ applied to a set of variables~$V$ as
	\begin{align*}
	\CheckAp{r}{V} &= \bigcup_{(P,D) \in \DP{r}, D \subseteq V} P.
	\end{align*}
	A rule~$r$ is globally safe if $\Vars{r}$ is the least fixed point of $\CheckOp{r}$ and each aggregate and conditional literal is locally safe.
	\\
	We define operator~$\CheckOp{e,G}$ for an element~$e$ of an aggregate~$a$ applied to a set of variables~$V$ as
	\begin{align*}
		\CheckAp{e,G}{V} &= G \cup \bigcup_{(P,D) \in \DP{e}, D \subseteq V} P.
	\end{align*}
	$a$ is locally safe if for each element $e \in elem(a)$, $\Vars{e}$ is the least fixed point of $\CheckOp{e,G}$
	\\
	We define operator~$\CheckOp{l,G}$ for an conditional literal~$l$ applied to a set of variables~$V$ as
	\begin{align*}
		\CheckAp{l,G}{V} &= G \cup \bigcup_{(P,D) \in dep_l(l), D \subseteq V} P.
	\end{align*}
	$l$ is locally safe if $\Vars{l}$ is the least fixed point of $\CheckOp{l,G}$
	\section{Other Examples}
	\begin{align*}
		dep(p(X,Y+Y)) &= \dep{pt(X,Y+Y), \emptyset}{\emptyset, dt(X,Y+Y)}
		\\ &= \dep{pt(X) \cup pt(Y+Y), \emptyset}{\emptyset, dt(X) \cup dt(Y+Y)}
		\\ &= \dep{\set{X} \cup \emptyset, \emptyset}{\emptyset, \emptyset \cup vars(Y+Y)}
		\\ &= \dep{\set{X}, \emptyset}{\emptyset, \set{Y}}
	\end{align*}
\end{document}
